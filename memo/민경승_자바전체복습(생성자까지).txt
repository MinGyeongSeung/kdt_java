자바 전체복습(생성자 까지)

자료형 51p
기본 자료형
- 실제 데이터 값을 저장

참조 변수형
- 데이타가 저장되어 있는 메모리 번지를 저장
- 기본값이 정해져 있지 않기 때문에 null 값 존재

참조 자료형 62 ~ 63p
- 프로그램을 실행할때 Stack메모리와 Heap 메모리 공간으로 나뉨
Stack -> 기본 자료형, 참조 자료형의 주소값
Heap -> 참조 자료형

클래스 개념을 활용하여 a 라는 객체를 생성
String a = new String("apple");
String b = new String("banana");

형 변환 66p
- byte는 -128 ~ 127의 범위를 가지며, 127을 넘으면  다시 -128부터 1을 셈

자동 형 변환 68p
- 작은 자료형에서 큰 자료형으로는 자동 형 변환 (데이터 손실 X)

강제 형 변환 70 ~72p
- 크기가 큰 자료형에서 작은 자료형으로 옮김 (데이터 손실 가능성 O)
※ 자동 형 변환은 업 캐스팅(묵시적 형 변환) 이라고도 하며, 강제 형 변환을 다은 캐스팅(명시적 형 변환)

데이터 입력 73p
- import java.util.Scanner; 구문은 자바에서 제공하는 구성 요소를 사용한다는 의미
System.in은 키보드로 입력 받는다는 의미이며, 객체명은 임의로 설정 할 수 있음

정수형 메서드
byte nextByte()
short nextShort()
int nextInt()
long nextLing()

실수형 메서드
float nextFloat()
double nextDouble()

문자형
String nextLine()
String next()

응용문제 76 ~ 77p

연산 80p
- 연산이란 데이터를 처리하고 결과를 산출하는 작업
- 연산은 항과 연산자로 이루어지며, 항은 연산에 사용되는 값, 연산자는 기호
- 항과 연산 과정을 나열한것이 연산식

연산자 우선순위와 연산 방향 82p
최 (괄호):
괄호 안에 있는 연산이 가장 먼저 처리됩니다. 

단 (단항 연산자):
단항 연산자는 부호 연산자(+,-), 증감 연산자(++, --), 논리 부정 연산자(!) 등을 포함하며, 단항 연산자 뒤에 위치한 피연산자에 대해 적용됩니다.
 
산 (산술 연산자):
곱셈(*), 나눗셈(/), 나머지(%), 덧셈(+), 뺄셈(-)과 같은 산술 연산이 진행됩니다. 

쉬 (쉬프트 연산자):
<< (왼쪽 쉬프트), >> (오른쪽 쉬프트)와 같은 비트 단위 연산이 수행됩니다. 

관 (관계 연산자):
크기 비교(>, <, >=, <=)나 같음(==, !=)을 확인하는 연산이 진행됩니다. 

리 (논리 연산자):
AND(&&), OR(||), NOT(!)과 같은 논리 연산이 수행됩니다. 

삼 (삼항 연산자):
조건 ? 값1 : 값2 와 같이 조건에 따라 다른 값을 반환하는 연산이 수행됩니다. 

대 (대입 연산자):
=, +=, -=, *=, /= 등과 같이 값을 할당하는 연산이 진행됩니다. 

응용문제 100 ~ 101p

조건문 105p
- 조건식의 true 또는 false라는 boolean 결과에 따라 어떤 구문을 실행할지 결정

조건문 108 ~ 109p
※ 조건식은 마름모라는 규칙을 약속
-------> : 흐름선
둥근사각형 : 터미널 - 프로그램의 시작과 끝
마름모 : 판단 - 프로그램이 실행될 수 있는 두 가지 경로(조건)을 비교하여 판단
직각사각형 : 처리 - 실행 구문(데이터의 값, 형태) 등을 변경함
평행사변형 : 입력/출력 - 데이터 입력 똔느 결과를 출력

if-else문 110p
- 조건식이 true일 때는 물론, false일 때는 어떤 코드를 실행시킬지 제어가능

if-else if문 115p
- 순서도 숙지

switch문 119p
- switch문에 조건으로 사용 될 수 잇는 연산자는 '==', 즉 두 개의 피연산자의 값이 같을때만 조건으로 활용 할 수 있음
- 따라서 하나의 변수 안에 저장되어 있는 값을 다수의 값과 비교해야 할 때 주로 사용

switch(변수) {
	case 값1 :
		코드;
		...
		break;
	case 값2 :
		코드;
		...
		break;
	default :
		코드;
※break;를 사용해 우리가 원하는 결과만 출력하고 그 다음에 switch문을 종료

응용문제 124 ~ 125p

for문 129p
for(초기화식; 조건식; 증감식) {
	실행문;
}
초기화식 -> 조건식 -> 실행문 -> 증감식

초기화식 : 반복문에 사용할 변수를 초기화
조건식 : 반복 수행할 범위를 구현
실행문 : 조건식이 true이면 false가 나올 때까지 반복하여 실행문을 수행
증감식 : 초기값을 증가하거나 감소

중첩 for문 132 ~ 133p
중첩 for문 이용하여 구구단 출력하기

	public static void main(String[] args) {
		
	for(int k=2;k<=9;k++) {
		System.out.print("제 "+k+"단	"); // 단 이름
	}                                  
		System.out.println(); // 없으면 구구단으로 줄바꿈이 되지 않음
				
	for(int j=1;j<=9;j++) {
		for(int i=2;i<=9;i++) {
			System.out.print(i+"X"+j+"="+(i*j)+"	");
		}
		System.out.println("");
	} 
}

이등변 삼각형 만들기 134p
	public static void main(String[] args) {
//	line = 4 → 삼각형의 높이 설정
//	line - i 만큼 " " 공백 출력 → 가운데 정렬을 위해 왼쪽 공백 추가
//	2 * i - 1 만큼 "*" 출력 → 홀수 개의 별을 찍어 삼각형 형태 생성
//	출력
		
	// 총 줄 수를 설정 (4줄)
	int line = 4;

	// 줄 수만큼 반복
	for (int i = 1; i <= line; i++) { 
		// 공백 출력 : 전체 줄 수 - 현재 줄 수 만큼 공백
		for (int j = 1; j <= line - i; j++) {
			System.out.print(" ");
			}
		// 별 출력 (2 * 현재 줄 번호 - 1 만큼)
		for (int k = 1; k <= 2 * i - 1; k++) {
			System.out.print("*");
			}
		// 한 줄 끝나면 줄바꿈
			System.out.println();
		}
	}

while문 135p
-조건식이 true일때 반복 실행
while (조건식) {
	실행문
}


do-while문 137p
- 먼저 루프를 한 번 실행 한 후에 조건식을 검사
do {
	실행문
} while(조건식);
조건이 true이면 실행

break 문 140p
- 반복문을 미리 종료할 때 사용
- 숫자 맞추기 게임

핵심정리 142p

응용문제 143p

배열 146p
- 배열이란, 같은 자료형의 변수를 지정하여 여러 데이터를 저장 할 수 있는 저장 공간을 의미
- 여러 데이터를 담을 수 있는 구조를 자료 구조(date structure) 라고 함
배열의 선언
자료형[] 변수 이름; = int [] arr;
자료형 변수 이름[]; = int arr [];
- 배열은 여러 개의 데이터를 저장하기 위한 별도의 공간이 필요
- 배열을 선언만 하고 값을 부여하지 않을 경우, 시스템은 배열 변수를 만들 때 'null' 이라는 키워드를 부여, 
배열 변수는 생성 되었지만, 아직 그 안에 값을 담을 공간들이 생성되지 않았다는 의미(Heap영역)

Arrays 159p
- Arrays는 기능을 사용할 때 점(.)을 이용해서 사용할 기능을 호출합니다. 먼저 배열 단위로 출력을 도와주는 toTsring()기능이 있음
- toString()은 반복문의 도움 없이 배열을 출력 할 수 있으며, 배열의 정의된 값들을 문자열(String)로 변환하여 출력함
- sytem.out.printI(Arrays.toString(arr))

배열의 복사 161p
- 앝은 복사 : 복사된 배열이나 원본 배열이 변경될 때 서로 같의 값이 함께 변경
- 깊은 복사 : 복사된 배열이나 원본 배열이 변경될 때 서로 간의 값은 바뀌지 않음

핵심정리 175p

응용문제 176 ~ 177p

객체와 객체 지향 프로그래밍(OOP) 180p
- 객체 지향 프로그래밍이란, 말 그래도 객체를 지향하는 프로그래밍
- 객체는 일반적으로 상태를 표현 할 수 있고 우리가 행동으로 실행 할 수 있는 모든 것을 말함,
- 이러한 객체를 중심으로 프로그램 구조를 설계하고 프로그래밍 하는 것을 객체지향 프로그래밍이라고 함

클래스 181p
- 객체를 생성하기 위한 제작 설명서

클래스의 용도 182p
- 실행용 : 프로그램 전체에서 단 하나의 클래스로, 프로그램의 실행을 전적으로 맡음, 기본적으로 main()을 가지고 있는 클래스,
 다른 클래스에서 사용하지 X
- 라이브러리용 : 다른 클래스에서 이용할 목적으로 선언되는 클래스
- 접근제한자 : 변수와 마찬가지로 클래스의 접근 범위를 제한
- class : class를 선언함
- 클래스 이름 : 변수처럼 이름을 가지고, 객체를 생성할 때 사용
※ 클래스 이름의 첫글짜는 대문자, 특수문자는 $ _ 만 가능

클래스의 구성 186p
- 필드 : 필드는 객체가 가져야 할 데이터 상태를 저장하는 변수, 클래스 내에 정의되고 객체가 생성될 때 그 객체와 함께 존재하는 데이터
※ 만약 클래스를 선언 할 때, 필드의 값을 초기화 하지 않으면 객체 생성 시 자동으로 기본값으로 초기화 됨

메서드 189 ~ 190p
-메서드란 객체의 기능을 담당하는 중괄호{} 블록을 말함, 특정 기능을 수행하는 코드를 따로 빼서 중괄호 안에 작성하며, 1개의 메서드는 일반적으로 1개의 기능을 수행

메서드 선언:
반환타입 메서드명() {
	// 기능을 수행할 코드 작성
}

- 리턴값이 있을 경우 : 리턴값의 자료형을 반환 타입으로 작성
- 리턴값이 없을 경우 : 반환 타입을 void라고 작성

- 메서드 사용
클래스명 객체명 = new 클래스명(); // 객체 생성
객체명.메서드명(); // 생성한 객체의 메서드 호출(사용)

생성자 192p
- 메서드 중에서 객체를 생성 할 때 반드시 호출해야 하는 메서드가 있으며, 이 메서드는 객체를 생성하면서 객체 변수를 초기화 하는 역활을 하는걸 생성자라 부른다

클래스명 객체명 = new클래스명();

인스턴스 멤버와 정적 멤버 193 ~ 195p
- 클래스 안에 선언된 필드와 메서드를 멤버라고 부름
- 클래스에 포함된 요소라는 의미로 '멤버'라는 용어를 사용하고 있음
- 인스턴스멤버 : 일반적으로 각 객체가 가지게 되는 필드와 메서드

정적 멤버 
- 모든 객체들이 공유하며 사용하는 하나의 필드와 메서드
- 필드와 메서드를 선얼할 때 static이라는 키워드가 붙은 멤버
- 객체가 아닌 클래스에 의존적인 요소
- static이 앞에 붙은 멤버들은 다른 멤버들과는 달리 객체를 생성하지 않고 바로 사용가능

응용문제 199p

메서드 202 ~ 203p
- 메서드란 클래스 안에서 특정 기능을 수행하기 위해 코드들을 따로 하나의 블록으로 묶어 놓은 집합을 말함
- 메서드를 작성해 놓으면, 필요할 때마다 재사용이 가능하며, 종복된 코드를 제거 할 수 있음
- 메서드처럼 코드들의 집합을 따로 분리 하는것을 '모듈화' 라고 함
- 가독성이 좋으며, 프로그램을 수정할 때 더욱 빠르고 쉽게 수정 할 수 있음

메서드 선언
접근제한자 반환타입 메서드이름() <-선언부 {	|
	//기능을  수행할 코드		| (body)
}					|

접근제한자 : 변수와 마찬가지로 해당 메서드에 접근 할 수 있는 범위를 결정
반환타입 : 메서드를 호출하면 메서드는 블록 안에 있는 코드들을 실행 한 후 결과값을 반환하는데, 어떤 타입으로 반환할 것인지 타입을 미리 정해줌
메서드 이름 : 변수처럼 이름을 가지고, 메소드를 호출 할 때 사용(카멜표기) 

메소드 호출 205p
메서드가 있는 클래스 참조변수 = new 클래스();
참조변수.메서드 이름();

package mgs0706;
//메서드 생성
public class Calculator {
	
	public int add(int a, int b) {
		return(a + b);
	}
}

package mgs0706;
// 메서드 호출
public class Practice06 {
	public static void main(String[] args) {
		// Calculator 클래스의 객체 생성
		Calculator calc = new Calculator();
		// 다른 클래스(Calculator)의 add 메서드 호출
		int result = calc.add(2, 2);
		System.out.println(result); // 출력
		
	}
}

매개변수 208p
- 특정 기능을 수행하기 위한 메서드는 기능을 수행할 때 사용할 인수를 받을 수 있는걸 매개변수라고 함
- 메서드를 정의할 때 , 소괄호() 안에 어떤 형태로 인수를 받을 지 작성할 수 있음

접근제한자 반환타입 메서드이름(자료형변수명) {
//기능을 수행할 코드들
}

return 212 ~ 213p
- 메서드를 호출할 때 매개변수를 전달 해 준것처럼, 필요에 따라 메서드로부터 실행한 결과값을 되돌려 받음
※ 메서드가 반환할 값이 있다면 반드시 return구문을 통해서 결과값을 반환해 주고 메서드를 종료 해야함
- 매개변수와 마찬가지로 리턴값의 자료형은 제한이 없음
※ 기본자료형
- 정수형 : byte, short, int, long
- 문자형(실수) : char
- 실수형 : float, double
- 논리형 : boolean
※ 참조자료형
- 배열 클래스등

- 자료형의 크기의 따라 실제로 던질 리턴값보다 작은 자료형으로 자동 형변환 되어 반환하는 것도 가능함
- return 문은 결과값 반환과 동시에 메소드를 종료시키는 구문

getter와 setter 메서드 218 ~ 220p 
- 객체 지향 프로그래밍에서는 메서드를 통해서 필드의 값을 불러오고, 필드의 값을 변경하는 방법을 이용함
※ 필드를 보호 할 수 있음,
※ 메서드에서 필드에 들어갈 값을 검증 한 후 필드에 대입 가능,
※ 외부에서 사용할 필드의 값을 정제 한 후 값을 제공 할 수 있음.

setter 메서드
- 일반적으로 setter 메소드를 사용할 때는, 필드의 값을 객체 외부에서 직접 넣지 못하도록 필드에 접근을 제한함.
- 필드가 선언되어 있는 클래스에서만 접근 가능한 필드는 private 라고 표현 함
- private 필드는 필드 앞에 private을 작성하여 선언함

getter 메서드
- private 필드를 객체 외부에서 값을 불러오기 위해 구현하는 메서드를 'getter'라고 함
- private 필드는 객체 외부에서는 접근이 불가능하지만, 필드가 선언된 클래스에서는 어디서든 접근 할 수 있음

핵심정리 222p

응용문제 223 ~ 225p

생성자 228 ~ 232p
- 생성자란 객체를 생성할 때 호출되어 객체의 초기화를 담당하는 특별한 메서드
- 객체를 생성하고 초기화 하기 위해서는 반드시 생성자를 호출해야 함
- 라이브러리용 클래스는 모두 생성자를 가지고 있음

생성자 호출 위치
- 일반 메서들과는 다르게, 생성자는 호출할 수 있는 곳이 정해져 있음.
- 생성자는 클래스를 기반으로 객체를 생성할 떄, 객체의 초기화를 담당하는 역할을 하므로 객체를 생성할 때만 호출 할 수 있음
- 생성자를 호출 할 때는 new 키워드를 함께 사용
클래스명 객체명 = new클래스명();

기본생성자
- 하나 이상의 생성자가 정의되어 있어야 함, 클래스를 생성하면서 개발자가 직접 생성자를 선언하지 않았지만, 자바 컴파일러가 기본 생성자를 자동으로 제공해줌

생성자 선언 이유
- 생성자는 객체를 생성함과 동시에 객체를 초기화 할 수 있음
- 생성자를 통해 객체를 초기화한다는 것은 필드와 메서드를 호출하는 등 객체를 사용하기 위해 객체를 메모리에 올린다는 의미

생성자를 통한 필드 초기화
- 생성자를 통하지 않고 클래스에서 필드를 선언할 때 필드를 초기화 할 수 있음
public class Snack {
	int price = 2000;
	...
}

생성자 오버로딩 235p
- 자바는 생성자를 여러 개 선언하는 것을 허용하고 있으며, 상황에 따라 매개변수 없이 또는 1개, 2개 등 외부에서 제공할 수 있는 데이터만큼만 매개변수로 전달하여 객체를 생성할 수 있게 하는 방법
- 생성자를 다양한 형태로 선언하는 것을 '생성자 오버로딩' 이라고 함
- 생성자 오버로딩은 생성자 매개변수의 자료형, 개수, 순서로 생성자를 구분하여 선언 할 수 있음

this 와 this() 240 ~ 241p
this
- 객체 자기 자신 스스로 참조
- this 참조 변수는 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수, this를 필드에 붙여서 사용하면, 중괄호{} 안에서도 같은 이름의 매개변수와 필드를 구분해서 사용 할 수 있음

this(매개변수1, 매개변수2, ...)
- this() 메서드는 같은 클래스 안에 있는 생성자 중 매개변수의 개수, 자료형, 순서에 맞는 다른 생성자를 호출하는 메서드로 생성자 내부에서만 사용할 수 있음

핵심정리 243p

응용문제 244 ~ 245p








